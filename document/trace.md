# 存储结构

## 摘要

本文档描述的存储结构为概要性描述，只描述也一些可见的必要的字段。最终存储结构会较以下内容略微复杂。

最终存储过程是Collector高速写入Segments数据到存储系统中，由存储系统依据预设的汇总算法进行拓扑图汇总。前期考虑到
Collector已经具备了拓扑图汇总功能，那么拓扑图将直接由Collector生成并推送到存储系统中。

存储结构是value写入后，不要进行修改

## 总体存储结构
```

        +-----------+          +----------------+
        |           |          |                |
+------->  MemTable +---------->  StorageEngine |
        |           |          |                |
        +-----------+          +----------------+
```

 1. MemTable: 数据首先缓存在一块内存中，用作数据批量汇总(如汇总1-10分钟)，然后生成待写入数据包。
 1. StorageEngine: 数据存储引擎。由于Trace数据Immutable的性质，且较关注近期产生的数据。故使用LSM结构的存储引擎较为合理。且LSM天生
的Key-Value形式非常适合分布式存储。

## 数据格式

```
+------------------+   +------------------+   +------------------+
|                  |   |                  |   |                  |
| Time Range Bulk1 |   | Time Range Bulk2 |   | Time Range Bulk1 | ...
|                  |   |                  |   |                  |
+------------------+   +------------------+   +------------------+
```

时间区间Bulk：将一定时间范围的数据的数据统一存储。便于删除与按照时间范围查找。一般时间范围定位1小时左右。

```
+---------------------------------+
|                                 |
|        Time Range Bulk          |
|                                 |
|   +-------------------------+   |
|   |                         |   |
|   |     Trace Storage       |   |
|   |                         |   |
|   +-------------------------+   |   ....
|                                 |
|                                 |
|   +-------------------------+   |
|   |                         |   |
|   |     Graph Storage       |   |
|   |                         |   |
|   +-------------------------+   |
|                                 |
|                                 |
|   +-------------------------+   |
|   |                         |   |
|   |     Timeseries Storage  |   |
|   |                         |   |
|   +-------------------------+   |
|                                 |
+---------------------------------+

```

 1. Trace Storage：包含Trace数据存储
 1. Graph Storage：包含拓扑图数据的存储

## Trace Storage

### 数据格式
```
+-----------------+-------------+
|                 |             |
|       Key       |  Value      |
|                 |             |
+---------+------------+----+---+
|         |       |    |    |   |
| trace_id|time   |seg1|seg2|...|
|         |       |    |    |   |
+---------+-------+----+----+---+

+---------------------+
|                     |
|      Seg            |
|                     |
+----+------+---------+
|    |      |         |
| len| Value| crc32   |
|    |      |         |
+----+------+---------+

```

每个segment的长度是不同的，所以len代表了value的长度，方便顺序查找。crc32用于校验value的有效性。

1. 写入时，使用Memtable积攒一定量的segment。然后批量写入一条，time为插入时的时间。
1. 追加时，与写入类似，但不会append之前的value，而是新增一条数据
1. 查询一个trace_id的数据时，使用prefix扫描。可能会有多条数据。

### 索引结构

由于LSM树本质是索引结构，故使用key来存储索引。索引内容包括timestamp，成功与否，持续时间和操作名称等。
索引构建由用户自定义。

查询时，首先根据条件查询响应的索引，然后通过索引获取trace_id 然后通过trace_id查询到trace数据。

## Graph Storage

```
+----------------------+---------------------+
|                      |                     |
|       Key            |   value             |
|                      |                     |
+--------------------------------------------+
|                      |                     |
|   rel_gloable_id     |    posting_list     |
|                      |                     |
+----------------------+---------------------+

+---------------------+   +---------------------+
|                     |   |                     |
|     rel_global_id   |   |    posting_list     |
|                     |   |                     |
+---------+-----------+   +---------+--------+--+
|         |           |   |         |        |  |
| graph_id|pre_node_id|   | posting1|posting2|..|
|         |           |   |         |        |  |
+---------+-----------+   +---------+--------+--+

+-----------------------------+
|                             |
|    posting                  |
|                             |
+-------+------------+--------+
|       |            |        |
| rel_id|next_node_id|label   |
|       |            |        |
+-------+------------+--------+

```

pre_node_id，next_node_id分别代表前一个节点和后一个节点。label可以存储关系中的属性。
该存储描述在时间Bulk中的静态关系图。

1. 写入时，首先查询关系是否存在，如果存在就不进行插入操作。当前Bulk的图数据缓存到Memtable，以减少IO.
1. 追加时，读取原有value直接在尾部追加posting。该操作只发挥发生在历史Bulk中。
1. 查询时，需要Timeseries Storage配合。首先根据事件范围确定Bulk，在Timeseries中查找该事件范围的数据。
具体方法是，target_id是graph_id 。使用graph_id和beging_timestamp粗略的进行数据查找。然后attr中保存
rel_id和统计类型,用来区分该键值对是针对哪个关系的哪一类统计。最后在value中依据offset确定判断最后统计的结果。
得到本次需要展示的所有rel_id后，然后遍历grahp结构进行图遍历操作，查找到所有关系。

查找统计信息和图遍历完成后，如果时间范围跨越多个Bulk，那么需要将统计信息和图遍历结果分别进行合并操作。

该查找方案，首先使用条件在大数据集(Timeseries)中查找到目标数据并进行汇总。得到rel_id后再从小数据集中(Graph)
查找关系。这样相比先进行图拓扑计算然后汇总数据，可以有效降低IO次数。

## Timeseries Storage

```
+---------------------------------------------+---------------------------------------+
|                                             |                                       |
|       Key                                   |      Value                            |
|                                             |                                       |
+----------+-----------------+-------------------------+----------+--------+----------+
|          |                 |                |        |          |        |          |
| target_id|begin_timestamp  | attr           |  offset| Value_len| Value  |  ....    |
|          |                 |                |        |          |        |          |
+----------+-----------------+----------------+--------+----------+--------+----------+
```
每条记录保存一定时间范围之内的数据，比如10分钟。
target_id如果为graph_id 可以保存调用数量信息，如果为cpu采样id可以保存cpu采样信息等。
begin_timestamp是这段时间的开始时间。
attr是该计算目标的而外索引信息
offset是相距begin_timestamp的时间偏移量。

1. 写入时在内存中汇总一定时间的数据，批量写入。每个value是批量汇总的结果
1. 没有追加操作，新数据会产生新的键值对。
1. 查询时间范围的数据需要结合beging_timestamp和offset确定需要的value

## 元数据存储

存储一些必要的元数据信息
